# 绩效佣金计算修复说明

## 问题现象

1. **生产环境（旧代码）**：修改备注或系数时，会自动计算佣金 ✅
2. **开发环境（新代码）**：修改备注或系数后，佣金不计算，显示¥0.00 ❌
3. **旧订单（修改备注代码之前）**：修改系数会自动计算佣金 ✅
4. **新订单（修改备注代码之后）**：修改系数或备注都不会计算佣金 ❌

## 问题根本原因

### 原因1：前端 `@change` 事件触发问题（次要）

Element Plus 的 `el-select` 组件在添加 `allow-create` 属性后，`@change` 事件的触发机制发生了变化。当用户输入自定义内容时，不会立即触发 `@change` 事件。

**解决方案**：添加 `@blur` 事件作为备用触发方式

### 原因2：待处理订单不计算预估佣金（核心问题）⚠️

**这是真正导致佣金显示为0的原因！**

后端佣金计算逻辑在统计销售人员的总业绩/总单数时，只统计 `performanceStatus = 'valid'` 的订单。

从截图看，所有订单的绩效状态都是"待处理"（pending），而不是"有效"（valid）。当修改待处理订单的系数时：

1. 计算佣金时统计该销售人员的有效订单数为0
2. 总单数为0，无法匹配任何阶梯配置
3. 导致佣金为0

**业务逻辑问题**：

- "预估佣金"应该是预估值，即使订单还是"待处理"状态，也应该显示预估的佣金
- 只有设置为"无效"状态时，佣金才应该是0
- 待处理订单应该假设它会变成有效，计算预估佣金

## 解决方案

### 1. 前端：添加 `@blur` 事件（已实施）

为备注和系数字段添加 `@blur` 事件监听，确保用户失去焦点时也能触发更新：

```vue
<!-- 备注字段 -->
<el-select
  v-model="row.performanceRemark"
  @change="(val: string) => updatePerformance(row, 'performanceRemark', val)"
  @blur="() => handleRemarkBlur(row)"
>
  <!-- ... -->
</el-select>

<!-- 系数字段 -->
<el-select
  v-model="row.performanceCoefficient"
  @change="(val: number) => updatePerformance(row, 'performanceCoefficient', val)"
  @blur="() => handleCoefficientBlur(row)"
>
  <!-- ... -->
</el-select>
```

实现防抖的 blur 处理函数，使用 300ms 延迟避免与 `@change` 事件冲突。

### 2. 后端：支持待处理订单的预估佣金计算（已实施）

修改 `calculateCommission` 函数，添加 `currentOrderStatus` 参数：

```typescript
async function calculateCommission(
  orderAmount: number,
  coefficient: number,
  departmentId?: string,
  userId?: string,
  startDate?: string,
  endDate?: string,
  currentOrderStatus?: string // 🔥 新增：当前订单的绩效状态
): Promise<number>
```

在统计销售人员的总业绩/总单数时，如果当前订单是待处理状态，假设它会变成有效，将其加入统计：

```typescript
// 按单数计提示例
let totalCount = 0;
if (userId) {
  const query = orderRepo.createQueryBuilder('o')
    .select('SUM(o.performanceCoefficient)', 'total')
    .where('o.createdBy = :userId', { userId })
    .andWhere('o.status IN (:...statuses)', { statuses: signedStatuses })
    .andWhere('o.performanceStatus = :ps', { ps: 'valid' })
    .andWhere('o.performanceCoefficient > 0');

  if (startDate) query.andWhere('o.createdAt >= :startDate', { startDate });
  if (endDate) query.andWhere('o.createdAt <= :endDate', { endDate: `${endDate} 23:59:59` });

  const result = await query.getRawOne();
  totalCount = parseFloat(result?.total || '0');
  console.log('[佣金计算] 统计签收订单数量（系数合计，只统计有效订单）:', totalCount);
  
  // 🔥 如果当前订单是待处理状态，假设它会变成有效，加入统计
  if (currentOrderStatus === 'pending') {
    totalCount += coefficient;
    console.log('[佣金计算] 当前订单是待处理，假设有效后总单数:', totalCount);
  }
}
```

### 3. 更新API调用（已实施）

在单个更新和批量更新API中，传入当前订单的绩效状态：

```typescript
// 单个更新
const commission = await calculateCommission(
  order.totalAmount,
  order.performanceCoefficient,
  order.createdByDepartmentId,
  order.createdBy,
  startDate as string,
  endDate as string,
  order.performanceStatus // 🔥 传入当前订单的状态
);

// 批量更新
const commission = await calculateCommission(
  order.totalAmount,
  order.performanceCoefficient,
  order.createdByDepartmentId,
  order.createdBy,
  startDate as string,
  endDate as string,
  order.performanceStatus // 🔥 传入当前订单的状态
);
```

## 佣金计算逻辑说明

### 按单数计提（commissionType = 'count'）

1. **统计该销售人员的签收订单数量**：
   - 只统计状态为 `delivered/completed/signed` 的订单
   - 只统计有效订单（`performanceStatus = 'valid'`）
   - 只统计系数>0的订单
   - 总数量 = SUM(系数)
   - 🔥 如果当前订单是待处理，假设有效后加入统计

2. **根据总数量匹配阶梯单价**：
   - 例如：0-10单 → 120元/单，10-80单 → 130元/单

3. **计算单个订单佣金**：
   - 单个订单佣金 = 系数 × 阶梯单价

### 按金额计提（commissionType = 'amount'）

1. **统计该销售人员的签收业绩总金额**：
   - 只统计状态为 `delivered/completed/signed` 的订单
   - 只统计有效订单（`performanceStatus = 'valid'`）
   - 只统计系数>0的订单
   - 总金额 = SUM(订单金额 × 系数)
   - 🔥 如果当前订单是待处理，假设有效后加入统计

2. **根据总金额匹配阶梯比例**：
   - 例如：0-10000元 → 5%，10000-50000元 → 8%

3. **计算单个订单佣金**：
   - 单个订单佣金 = 订单金额 × 系数 × 阶梯比例

## 测试验证

### 测试场景

1. ✅ 待处理订单修改系数 → 应该显示预估佣金
2. ✅ 待处理订单修改备注 → 应该显示预估佣金
3. ✅ 待处理订单设置为有效 → 佣金保持不变
4. ✅ 待处理订单设置为无效 → 佣金变为0
5. ✅ 有效订单修改系数 → 佣金重新计算
6. ✅ 旧订单修改系数 → 佣金正常计算

### 验证步骤

1. 打开绩效管理页面，筛选本月数据
2. 找到一个待处理订单（绩效状态为"待处理"）
3. 修改系数（例如从1.0改为1.5）
4. 观察预估佣金是否自动计算并显示
5. 打开浏览器控制台（F12），查看是否有API请求发送
6. 检查后端日志，确认佣金计算逻辑正常执行

### 预期结果

- 修改系数后，预估佣金应该立即显示（不为0）
- 后端日志应该显示：
  ```
  [佣金计算] 统计签收订单数量（系数合计，只统计有效订单）: X
  [佣金计算] 当前订单是待处理，假设有效后总单数: X + 系数
  [佣金计算] ✓ 匹配阶梯，单价: XXX
  [佣金计算] 最终佣金 = 系数 × 单价 = XXX
  ```

## 部署说明

### 开发环境

1. 后端服务已重启，修改已生效
2. 前端需要刷新页面（Ctrl+F5）清除缓存

### 生产环境

1. 更新后端代码：
   ```bash
   cd backend
   git pull
   npm install
   pm2 restart crm-backend
   ```

2. 更新前端代码：
   ```bash
   cd admin
   git pull
   npm install
   npm run build
   # 将 dist 目录部署到生产服务器
   ```

3. 验证：
   - 打开绩效管理页面
   - 修改待处理订单的系数
   - 确认预估佣金正常显示

## 相关文件

- `src/views/Finance/PerformanceManage.vue` - 前端绩效管理页面（已修复）
- `backend/src/routes/finance.ts` - 后端佣金计算逻辑（已修复）
- `docs/临时文件/绩效佣金计算问题排查.md` - 详细排查文档
- `scripts/check-commission-calculation.sql` - 佣金计算检查脚本

## 注意事项

1. **预估佣金 vs 实际佣金**：
   - 待处理订单显示的是"预估"佣金，假设订单会变成有效
   - 只有设置为"有效"状态后，佣金才会计入统计卡片的"预估佣金汇总"

2. **阶梯配置**：
   - 确保在"配置管理"中已配置佣金阶梯
   - 阶梯配置必须是启用状态（`is_active = 1`）
   - 可以配置部门级别的阶梯，也可以配置全局阶梯

3. **时间范围**：
   - 佣金计算会考虑筛选的时间范围
   - 只统计时间范围内的订单
   - 确保筛选的时间范围包含需要计算的订单

4. **订单状态**：
   - 只有已签收（delivered/completed/signed）的订单才会计入统计
   - 已发货但未签收的订单不会计入统计
