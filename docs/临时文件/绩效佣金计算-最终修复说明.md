# 绩效佣金计算 - 最终修复说明

## 问题描述

绩效管理页面中，修改订单的系数、备注或有效状态后，预估佣金字段没有计算，显示为 ¥0.00。

## 核心需求（已明确）

**不管订单的绩效状态是什么（待处理、有效、无效），只要修改了以下3个字段之一：**
1. 有效状态
2. 系数
3. 备注

**就应该立即根据该销售人员的有效订单数量去匹配阶梯档位，计算这条订单的预估佣金。**

## 佣金计算逻辑

### 按单数计提（commissionType = 'count'）

1. **统计该销售人员的有效订单数量**：
   ```sql
   SELECT SUM(performance_coefficient) AS total
   FROM orders
   WHERE created_by = '销售人员ID'
     AND status IN ('delivered', 'completed', 'signed')  -- 只统计已签收订单
     AND performance_status = 'valid'                     -- 只统计有效订单
     AND performance_coefficient > 0
     AND created_at >= '开始日期'
     AND created_at <= '结束日期'
   ```
   - 注意：这里统计的是**已经设置为"有效"状态的订单**
   - 不包括当前正在修改的这条订单（除非它已经是有效状态）

2. **根据有效订单数量匹配阶梯档位**：
   - 例如：0-10单 → 120元/单，10-80单 → 130元/单，80-300单 → 140元/单

3. **计算当前订单的预估佣金**：
   ```
   预估佣金 = 当前订单的系数 × 匹配的阶梯单价
   ```

### 示例

假设销售人员A在本月有以下订单：
- 订单1：有效，系数1.0
- 订单2：有效，系数1.0
- 订单3：有效，系数0.5
- 订单4：待处理，系数1.0（当前正在修改的订单）

**计算步骤**：
1. 统计有效订单数量：1.0 + 1.0 + 0.5 = 2.5单
2. 匹配阶梯：2.5单在0-10单范围内，单价120元/单
3. 计算订单4的预估佣金：1.0 × 120 = 120元

**关键点**：
- 订单4虽然是"待处理"状态，但仍然会计算预估佣金
- 预估佣金是基于当前已有的有效订单数量来匹配阶梯
- 如果订单4后来设置为"有效"，有效订单数量会变成3.5单，可能匹配到不同的阶梯

## 修复内容

### 1. 前端修复（已完成）

添加 `@blur` 事件作为备用触发方式，确保用户失去焦点时也能触发更新：

```vue
<!-- 系数字段 -->
<el-select
  v-model="row.performanceCoefficient"
  @change="(val: number) => updatePerformance(row, 'performanceCoefficient', val)"
  @blur="() => handleCoefficientBlur(row)"
>
  <!-- ... -->
</el-select>

<!-- 备注字段 -->
<el-select
  v-model="row.performanceRemark"
  @change="(val: string) => updatePerformance(row, 'performanceRemark', val)"
  @blur="() => handleRemarkBlur(row)"
>
  <!-- ... -->
</el-select>
```

### 2. 后端修复（已完成）

简化佣金计算逻辑，移除了"假设待处理订单会变成有效"的逻辑：

```typescript
// 按单数计提
let totalCount = 0;
if (userId) {
  const query = orderRepo.createQueryBuilder('o')
    .select('SUM(o.performanceCoefficient)', 'total')
    .where('o.createdBy = :userId', { userId })
    .andWhere('o.status IN (:...statuses)', { statuses: signedStatuses })
    .andWhere('o.performanceStatus = :ps', { ps: 'valid' })  // 只统计有效订单
    .andWhere('o.performanceCoefficient > 0');

  if (startDate) query.andWhere('o.createdAt >= :startDate', { startDate });
  if (endDate) query.andWhere('o.createdAt <= :endDate', { endDate: `${endDate} 23:59:59` });

  const result = await query.getRawOne();
  totalCount = parseFloat(result?.total || '0');
  console.log('[佣金计算] 统计签收订单数量（系数合计，只统计有效订单）:', totalCount);
}

// 根据总单数匹配阶梯
let perUnit = 0;
for (const ladder of ladders) {
  const min = parseFloat(ladder.minValue?.toString() || '0');
  const max = ladder.maxValue ? parseFloat(ladder.maxValue.toString()) : Infinity;
  if (totalCount >= min && totalCount < max) {
    perUnit = parseFloat(ladder.commissionPerUnit?.toString() || '0');
    break;
  }
}

// 计算单个订单佣金
const commission = coefficient * perUnit;
```

## 测试验证

### 前提条件

1. 确保在"配置管理"中已配置佣金阶梯（按单数计提）
2. 确保有一些已签收且设置为"有效"的订单

### 测试步骤

1. 打开绩效管理页面，筛选本月数据
2. 找到一个待处理订单（绩效状态为"待处理"）
3. 修改系数（例如从1.0改为1.5）
4. 失去焦点或选择下拉选项
5. 观察预估佣金是否自动计算并显示

### 预期结果

- 修改系数后，预估佣金应该立即显示（不为0）
- 预估佣金 = 修改后的系数 × 匹配的阶梯单价
- 后端日志应该显示：
  ```
  [佣金计算] 统计签收订单数量（系数合计，只统计有效订单）: X
  [佣金计算] ✓ 匹配阶梯，单价: XXX
  [佣金计算] 最终佣金 = 系数 × 单价 = XXX
  ```

### 测试场景

| 场景 | 操作 | 预期结果 |
|------|------|----------|
| 待处理订单修改系数 | 系数从1.0改为1.5 | 预估佣金 = 1.5 × 阶梯单价 |
| 待处理订单修改备注 | 备注从"正常"改为"退货" | 预估佣金保持不变（只要系数不变） |
| 待处理订单设置为有效 | 有效状态从"待处理"改为"有效" | 预估佣金保持不变 |
| 待处理订单设置为无效 | 有效状态从"待处理"改为"无效" | 预估佣金变为0 |
| 有效订单修改系数 | 系数从1.0改为0.5 | 预估佣金重新计算 |

## 常见问题

### Q1: 为什么待处理订单也会显示预估佣金？

A: "预估佣金"是预估值，用于让销售人员和管理员提前了解订单的佣金情况。即使订单还是"待处理"状态，也应该显示预估的佣金。只有设置为"无效"状态时，佣金才应该是0。

### Q2: 预估佣金是基于什么计算的？

A: 预估佣金是基于该销售人员当前已有的"有效"订单数量来匹配阶梯档位，然后用当前订单的系数乘以匹配的阶梯单价。

### Q3: 如果没有有效订单，预估佣金会是0吗？

A: 是的。如果该销售人员在筛选的时间范围内没有任何有效订单，总单数为0，会匹配到第一个阶梯（0-X单），使用该阶梯的单价计算。

### Q4: 修改系数后，为什么预估佣金没有变化？

A: 可能的原因：
1. 没有配置佣金阶梯
2. 阶梯配置未启用（is_active = 0）
3. 前端 `@change` 或 `@blur` 事件没有触发
4. 后端服务没有重启

### Q5: 汇总卡片的"预估佣金"和单条订单的"预估佣金"有什么区别？

A: 
- 单条订单的"预估佣金"：不管订单状态是什么，都会计算显示
- 汇总卡片的"预估佣金"：只统计"有效"状态订单的佣金总和

## 部署说明

### 开发环境

1. 后端服务已重启，修改已生效
2. 前端刷新页面（Ctrl+F5）清除缓存即可

### 生产环境

1. 更新后端代码并重启服务：
   ```bash
   cd backend
   git pull
   npm install
   pm2 restart crm-backend
   ```

2. 更新前端代码并重新构建：
   ```bash
   cd admin
   git pull
   npm install
   npm run build
   # 将 dist 目录部署到生产服务器
   ```

## 相关文件

- `src/views/Finance/PerformanceManage.vue` - 前端绩效管理页面
- `backend/src/routes/finance.ts` - 后端佣金计算逻辑
- `scripts/check-commission-calculation.sql` - 佣金计算检查脚本
