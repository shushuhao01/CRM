# 业绩分享"服务器内部出错"诊断报告

## 问题现象
页面顶部弹出红色提示框：
- "请求失败"
- "服务器内部出错"

## 问题根源分析

### 1. 错误来源
错误提示来自 **Element Plus 的全局错误拦截器**，位于 `src/utils/request.ts`。

当后端 API 返回 500 错误时，请求拦截器会自动显示这个错误提示。

### 2. 后端错误原因
查看后端代码 `backend/src/routes/performance.ts` 第 14-72 行：

```typescript
router.get('/shares', async (req: Request, res: Response) => {
  try {
    // 查询 performance_shares 和 performance_share_members 表
    let sql = `SELECT ps.*,
               (SELECT JSON_ARRAYAGG(...) FROM performance_share_members psm ...) 
               FROM performance_shares ps WHERE 1=1`;
    
    const shares = await AppDataSource.query(sql, params);
    // ...
  } catch (error) {
    console.error('获取业绩分享列表失败:', error);
    res.status(500).json({ success: false, code: 500, message: '获取业绩分享列表失败' });
  }
});
```

**问题**：如果数据库中不存在 `performance_shares` 或 `performance_share_members` 表，SQL 查询会抛出异常，后端返回 500 错误。

### 3. 前端错误处理
查看前端代码 `src/views/Performance/Share.vue` 第 766-829 行：

```typescript
const loadShareRecords = async () => {
  loading.value = true
  try {
    const result = await performanceStore.loadPerformanceShares(params)
    totalRecords.value = result.total
    // ...
  } catch (error) {
    // 🔥 完全静默处理：不显示任何错误提示，只在控制台记录
    console.warn('[业绩分享] 加载数据失败，可能是表不存在或无数据:', error)
    totalRecords.value = 0
  } finally {
    loading.value = false
  }
}
```

**前端已经做了静默处理**，但错误提示仍然出现，说明：
- 错误提示来自 **全局请求拦截器**，在前端 catch 之前就已经触发了

### 4. 全局拦截器位置
错误提示来自 `src/utils/request.ts` 的响应拦截器：

```typescript
// 响应拦截器
request.interceptors.response.use(
  (response) => { /* ... */ },
  (error) => {
    // 🔥 这里会自动显示错误提示
    if (error.response?.status === 500) {
      ElMessage.error('服务器内部出错')
    }
    return Promise.reject(error)
  }
)
```

## 为什么生产环境正常？

生产环境数据库中已经有 `performance_shares` 和 `performance_share_members` 表，所以：
1. 后端 SQL 查询成功
2. 返回空数组 `{ shares: [], total: 0 }`
3. 前端正常显示"暂无数据"

## 为什么开发环境报错？

开发环境数据库（crm_local）可能缺少这两个表，所以：
1. 后端 SQL 查询失败（表不存在）
2. 返回 500 错误
3. 全局拦截器显示"服务器内部出错"
4. 前端虽然做了静默处理，但拦截器的提示已经显示了

## 解决方案（3个选项）

### 方案1：创建缺失的数据库表（推荐）✅
**优点**：
- 彻底解决问题
- 开发环境和生产环境保持一致
- 功能完全正常

**操作**：
1. 执行 `scripts/check-performance-shares-tables.sql` 检查表是否存在
2. 如果不存在，执行 `scripts/create-performance-shares-tables-dev.sql` 创建表
3. 刷新页面，不再报错

**风险**：无

---

### 方案2：后端添加表存在性检查
**优点**：
- 后端更健壮
- 即使表不存在也不会返回 500 错误

**修改位置**：`backend/src/routes/performance.ts`

```typescript
router.get('/shares', async (req: Request, res: Response) => {
  try {
    // 🔥 先检查表是否存在
    const [tableCheck] = await AppDataSource.query(
      `SELECT COUNT(*) as count FROM information_schema.TABLES 
       WHERE TABLE_SCHEMA = DATABASE() 
       AND TABLE_NAME = 'performance_shares'`
    );
    
    if (tableCheck.count === 0) {
      // 表不存在，返回空数据而不是错误
      return res.json({
        success: true,
        code: 200,
        message: '获取业绩分享列表成功',
        data: { shares: [], total: 0, page: 1, limit: 10 }
      });
    }
    
    // 原有查询逻辑...
  } catch (error) {
    // ...
  }
});
```

**风险**：
- 需要修改后端代码
- 每次请求都要检查表是否存在（性能影响小）

---

### 方案3：前端禁用特定 API 的错误提示
**优点**：
- 只修改前端
- 不影响其他功能

**修改位置**：`src/api/performance.ts`

```typescript
export const getPerformanceShares = async (params?: PerformanceShareListParams) => {
  try {
    // 🔥 添加配置，禁用此 API 的错误提示
    const data = await request.get('/performance/shares', { 
      params,
      showError: false  // 禁用全局错误提示
    })
    // ...
  } catch (error) {
    // 静默处理
    return {
      success: false,
      data: { shares: [], total: 0, page: 1, limit: 10 }
    }
  }
}
```

**前提**：需要 `request.ts` 支持 `showError` 配置项

**风险**：
- 如果 request.ts 不支持此配置，需要先修改拦截器
- 可能隐藏真正的错误

---

## 推荐方案

**强烈推荐方案1**：创建数据库表

**理由**：
1. 这是正确的解决方案，不是绕过问题
2. 开发环境应该和生产环境保持一致
3. 操作简单，风险为零
4. 功能完全正常，不会有任何副作用

**如果不想创建表**，可以选择方案2（后端检查）或方案3（前端禁用提示）

## 之前为什么会导致页面空白？

之前尝试添加 `showError: false` 时，可能：
1. 修改了不该修改的地方
2. 语法错误导致整个文件无法解析
3. 修改了全局拦截器，影响了所有请求

**本次不会出现这个问题**，因为：
- 方案1 只操作数据库，不修改代码
- 方案2 只修改后端，不影响前端
- 方案3 只修改特定 API，不影响全局

## 总结

| 方案 | 修改范围 | 风险 | 推荐度 |
|------|---------|------|--------|
| 方案1：创建表 | 数据库 | 无 | ⭐⭐⭐⭐⭐ |
| 方案2：后端检查 | 后端代码 | 低 | ⭐⭐⭐⭐ |
| 方案3：前端禁用 | 前端代码 | 中 | ⭐⭐⭐ |

**建议**：先执行方案1，如果不想创建表，再考虑方案2或方案3。
