# 绩效佣金计算问题排查指南

## 问题现象

1. **生产环境（旧代码）**：修改备注或系数时，会自动计算佣金 ✅
2. **开发环境（新代码）**：修改备注或系数后，佣金不计算，显示¥0.00 ❌
3. **旧订单（修改备注代码之前）**：修改系数会自动计算佣金 ✅
4. **新订单（修改备注代码之后）**：修改系数或备注都不会计算佣金 ❌

## 问题根本原因 ✅ 已找到

### 原因1：Element Plus 的 `@change` 事件触发问题

**Element Plus 的 `el-select` 组件在添加 `allow-create` 属性后，`@change` 事件的触发机制发生了变化！**

当用户输入自定义内容时，Element Plus 不会立即触发 `@change` 事件，需要用户明确选择下拉选项或失去焦点才会触发。

**解决方案**：添加 `@blur` 事件作为备用触发方式（已实施）

### 原因2：待处理订单不计算预估佣金 ⚠️ 核心问题

**这是真正导致佣金显示为0的原因！**

后端佣金计算逻辑在统计销售人员的总业绩/总单数时，只统计 `performanceStatus = 'valid'` 的订单：

```typescript
// 旧逻辑：只统计有效订单
const query = orderRepo.createQueryBuilder('o')
  .select('SUM(o.performanceCoefficient)', 'total')
  .where('o.createdBy = :userId', { userId })
  .andWhere('o.status IN (:...statuses)', { statuses: signedStatuses })
  .andWhere('o.performanceStatus = :ps', { ps: 'valid' })  // ⚠️ 只统计有效订单
  .andWhere('o.performanceCoefficient > 0');
```

**问题分析**：

1. 从截图看，所有订单的绩效状态都是"待处理"（pending），而不是"有效"（valid）
2. 当修改待处理订单的系数时，计算佣金时统计该销售人员的有效订单数为0
3. 总单数为0，无法匹配任何阶梯配置，导致佣金为0

**业务逻辑**：

- "预估佣金"应该是预估值，即使订单还是"待处理"状态，也应该显示预估的佣金
- 只有设置为"无效"状态时，佣金才应该是0
- 待处理订单应该假设它会变成有效，计算预估佣金

**解决方案**：

修改 `calculateCommission` 函数，当计算待处理订单的佣金时，假设它会变成有效，将其加入统计：

```typescript
// 新逻辑：待处理订单假设会变成有效
let totalCount = 0;
if (userId) {
  const query = orderRepo.createQueryBuilder('o')
    .select('SUM(o.performanceCoefficient)', 'total')
    .where('o.createdBy = :userId', { userId })
    .andWhere('o.status IN (:...statuses)', { statuses: signedStatuses })
    .andWhere('o.performanceStatus = :ps', { ps: 'valid' })
    .andWhere('o.performanceCoefficient > 0');

  if (startDate) query.andWhere('o.createdAt >= :startDate', { startDate });
  if (endDate) query.andWhere('o.createdAt <= :endDate', { endDate: `${endDate} 23:59:59` });

  const result = await query.getRawOne();
  totalCount = parseFloat(result?.total || '0');
  console.log('[佣金计算] 统计签收订单数量（系数合计，只统计有效订单）:', totalCount);
  
  // 🔥 如果当前订单是待处理状态，假设它会变成有效，加入统计
  if (currentOrderStatus === 'pending') {
    totalCount += coefficient;
    console.log('[佣金计算] 当前订单是待处理，假设有效后总单数:', totalCount);
  }
}
```

### 代码对比

**旧版本（b512f091）**：
```vue
<el-select
  v-model="row.performanceRemark"
  size="small"
  @change="(val: string) => updatePerformance(row, 'performanceRemark', val)"
>
  <el-option v-for="r in configData.remarkConfigs" :key="r.id" :label="getRemarkLabel(r.configValue)" :value="r.configValue" />
</el-select>
```

**新版本（添加自定义输入功能后）**：
```vue
<el-select
  v-model="row.performanceRemark"
  size="small"
  filterable
  allow-create          <!-- 🔥 这个属性导致 @change 事件不触发 -->
  default-first-option
  placeholder="选择或输入备注"
  @change="(val: string) => updatePerformance(row, 'performanceRemark', val)"
>
  <!-- 预设备注选项 + 自定义备注历史记录 -->
</el-select>
```

### 问题分析

1. **`allow-create` 模式的特殊行为**：
   - 当用户输入自定义内容时，Element Plus 不会立即触发 `@change` 事件
   - 需要用户明确选择下拉选项或失去焦点才会触发
   - 这导致用户输入后直接点击其他地方，`@change` 事件不触发

2. **影响范围**：
   - 备注字段：添加了 `allow-create` 属性，受影响
   - 系数字段：虽然没有 `allow-create`，但可能受到相同的事件机制影响

3. **为什么旧订单可以正常计算**：
   - 旧订单的备注值已经保存在数据库中
   - 修改系数时，备注字段没有变化，不受 `allow-create` 影响
   - 新订单的备注字段可能处于"待输入"状态，影响了整个表单的事件触发

## 解决方案 ✅ 已实施

### 1. 添加 `@blur` 事件作为备用触发方式

为备注和系数字段都添加 `@blur` 事件监听，确保用户失去焦点时也能触发更新：

```vue
<!-- 备注字段 -->
<el-select
  v-model="row.performanceRemark"
  @change="(val: string) => updatePerformance(row, 'performanceRemark', val)"
  @blur="() => handleRemarkBlur(row)"
>
  <!-- ... -->
</el-select>

<!-- 系数字段 -->
<el-select
  v-model="row.performanceCoefficient"
  @change="(val: number) => updatePerformance(row, 'performanceCoefficient', val)"
  @blur="() => handleCoefficientBlur(row)"
>
  <!-- ... -->
</el-select>
```

### 2. 实现防抖的 blur 处理函数

```typescript
// 备注字段失去焦点时的处理（备用触发方式）
const remarkBlurTimers = new Map<string, number>()
const handleRemarkBlur = (row: PerformanceOrder) => {
  // 清除之前的定时器
  const existingTimer = remarkBlurTimers.get(row.id)
  if (existingTimer) {
    clearTimeout(existingTimer)
  }

  // 延迟300ms执行，避免与 @change 事件冲突
  const timer = window.setTimeout(() => {
    if (row.performanceRemark && row.performanceRemark.trim() !== '') {
      console.log('[PerformanceManage] handleRemarkBlur triggered')
      updatePerformanceQuietly(row, 'performanceRemark', row.performanceRemark)
    }
    remarkBlurTimers.delete(row.id)
  }, 300)

  remarkBlurTimers.set(row.id, timer)
}

// 系数字段失去焦点时的处理（备用触发方式）
const coefficientBlurTimers = new Map<string, number>()
const handleCoefficientBlur = (row: PerformanceOrder) => {
  // 类似的实现...
}
```

### 3. 实现静默更新函数

为了避免 `@change` 和 `@blur` 同时触发导致重复提示，创建静默更新函数：

```typescript
// 静默更新绩效（不显示成功消息，用于 blur 事件）
const updatePerformanceQuietly = async (row: PerformanceOrder, field: string, value: any) => {
  try {
    // 验证逻辑...
    const data: any = {}
    data[field] = value

    // 添加到自定义历史记录
    if (field === 'performanceRemark' && value) {
      addCustomRemarkToHistory(value)
    }

    // 传入时间范围，用于计算阶梯佣金
    if (dateRange.value) {
      data.startDate = dateRange.value[0]
      data.endDate = dateRange.value[1]
    }

    console.log('[PerformanceManage] updatePerformanceQuietly API call:', row.id, data)
    await financeApi.updatePerformance(row.id, data)
    // 不显示成功消息，避免重复提示
    loadData()
    loadStatistics()
    eventBus.emit(EventNames.PERFORMANCE_UPDATED, { type: field, orderIds: [row.id] })
  } catch (e) {
    console.error('[PerformanceManage] updatePerformanceQuietly error:', e)
    // 静默失败，不显示错误消息
  }
}
```

### 4. 工作原理

1. **正常情况**：用户选择下拉选项 → `@change` 事件触发 → 显示"更新成功"消息
2. **备用情况**：用户输入自定义内容后失去焦点 → `@blur` 事件触发 → 静默更新（不显示消息）
3. **防抖机制**：300ms 延迟确保 `@change` 优先执行，避免重复更新
4. **去重逻辑**：使用 Map 存储定时器，每次 blur 时清除旧定时器

## 测试验证

### 测试场景

1. ✅ 修改系数（选择下拉选项）→ 应该自动计算佣金
2. ✅ 修改备注（选择预设选项）→ 应该自动计算佣金
3. ✅ 修改备注（输入自定义内容）→ 失去焦点后应该自动计算佣金
4. ✅ 旧订单修改系数 → 应该正常计算佣金
5. ✅ 新订单修改系数或备注 → 应该正常计算佣金

### 验证步骤

1. 清空浏览器缓存和 localStorage
2. 刷新页面，加载绩效管理数据
3. 测试修改系数：选择不同的系数值，观察预估佣金是否更新
4. 测试修改备注：选择预设备注，观察预估佣金是否更新
5. 测试自定义备注：输入自定义内容，失去焦点后观察预估佣金是否更新
6. 检查浏览器控制台，确认 API 请求正常发送
7. 检查后端日志，确认佣金计算逻辑正常执行

## 后续优化建议

1. **考虑移除 `allow-create` 属性**：
   - 如果自定义备注功能不是必需的，可以移除 `allow-create` 属性
   - 恢复到旧版本的简单下拉选择，避免事件触发问题

2. **使用 `v-model` 的 `@update:modelValue` 事件**：
   - Element Plus 的 `v-model` 会触发 `@update:modelValue` 事件
   - 可以尝试监听这个事件作为更可靠的触发方式

3. **添加手动保存按钮**：
   - 为每一行添加"保存"按钮，让用户明确触发保存操作
   - 避免依赖自动触发机制

## 佣金计算逻辑（参考）

### 计算条件
1. 订单状态必须是"有效"（performanceStatus = 'valid'）
2. 系数必须大于0（performanceCoefficient > 0）
3. 必须配置了佣金阶梯（CommissionLadder表）

### 计算公式

#### 按金额计提（commissionType = 'amount'）
1. 统计该销售人员在时间范围内的签收业绩总金额
   - 只统计状态为 delivered/completed/signed 的订单
   - 只统计有效订单（performanceStatus = 'valid'）
   - 只统计系数>0的订单
   - 总金额 = SUM(订单金额 × 系数)

2. 根据总金额匹配阶梯比例
   - 例如：0-10000元 → 5%，10000-50000元 → 8%

3. 单个订单佣金 = 订单金额 × 系数 × 阶梯比例

#### 按单数计提（commissionType = 'count'）
1. 统计该销售人员在时间范围内的签收订单数量
   - 只统计状态为 delivered/completed/signed 的订单
   - 只统计有效订单（performanceStatus = 'valid'）
   - 只统计系数>0的订单
   - 总数量 = SUM(系数)

2. 根据总数量匹配阶梯单价
   - 例如：0-10单 → 50元/单，10-50单 → 80元/单

3. 单个订单佣金 = 系数 × 阶梯单价

## 相关文件

- `src/views/Finance/PerformanceManage.vue` - 前端绩效管理页面（已修复）
- `backend/src/routes/finance.ts` - 后端佣金计算逻辑（无需修改）
- `docs/临时文件/绩效佣金计算问题排查.md` - 本文档
